# ğŸ¯ ARTICLE I: ANATOMY OF CONSTITUTIONAL PROMPT

**The 7 Components That Transform Prompts from Amateur to Production-Ready**

---

## ğŸ“œ CONSTITUTIONAL AUTHORITY

This article establishes the **anatomy** of a constitutional prompt - the 7 non-negotiable components that distinguish professional AI orchestration from amateur "prompt engineering."

**Legal Force:**
- âœ… All prompts generated by MVCA MUST include these 7 components
- âœ… Skipping components is a **constitutional violation**
- âœ… These components enforce the Three Immutable Laws from Segment 1

**Why This Matters:**

````
Amateur Prompt (20% success rate):
"Create a login page"

Constitutional Prompt (90% success rate):
[7 components totaling 500-1000 words of precise specification]

Result: Constitutional prompts produce production-ready code in ONE iteration.
Amateur prompts require 5-10 iterations and still have security holes.
````

---

## ğŸ” THE PROBLEM WITH TRADITIONAL PROMPTS

### Why Most Prompts Fail

**Traditional "prompt engineering" teaches:**
- Be clear and specific
- Provide examples
- Use good grammar

**But this is NOT ENOUGH for production software.**

### The 5 Fatal Flaws of Amateur Prompts

**FLAW #1: NO PERSONA (AI doesn't know its role)**
````
âŒ Amateur: "Write authentication code"
â†’ AI Response: Generic code from tutorial websites

âœ… Constitutional: "You are a senior security architect with 10 years of OAuth experience"
â†’ AI Response: Production-grade code with security best practices
````

**FLAW #2: NO CONTEXT (AI works in a vacuum)**
````
âŒ Amateur: "Add user profiles"
â†’ AI Response: Creates incompatible code (doesn't know your stack)

âœ… Constitutional: Provides full tech stack, existing architecture, constraints
â†’ AI Response: Integrates seamlessly with existing codebase
````

**FLAW #3: NO SECURITY MANDATES (AI takes shortcuts)**
````
âŒ Amateur: "Create login form"
â†’ AI Response: Client-side only validation, no rate limiting, passwords in localStorage

âœ… Constitutional: Enforces 10 Strategic Commandments explicitly
â†’ AI Response: Server-side validation, bcrypt hashing, database sessions, rate limiting
````

**FLAW #4: NO META-INSTRUCTIONS (AI guesses your intent)**
````
âŒ Amateur: "Build checkout flow"
â†’ AI Response: Monolithic code, no error handling, no testing

âœ… Constitutional: "Think step-by-step, validate edge cases, explain trade-offs"
â†’ AI Response: Modular code, comprehensive error handling, testing included
````

**FLAW #5: NO OUTPUT VALIDATION CRITERIA (AI doesn't know when it's done)**
````
âŒ Amateur: "Optimize performance"
â†’ AI Response: Random optimizations with no metrics

âœ… Constitutional: "Reduce page load to <500ms, provide before/after benchmarks"
â†’ AI Response: Targeted optimizations with measurable results
````

---

## ğŸ—ï¸ THE 7 CONSTITUTIONAL COMPONENTS

Every constitutional prompt MUST include these 7 components in order:

````
COMPONENT 1: PERSONA ASSIGNMENT      (Who AI pretends to be)
COMPONENT 2: CONTEXT INJECTION       (What AI knows about your project)
COMPONENT 3: TASK DEFINITION         (What AI needs to do)
COMPONENT 4: REQUIREMENTS            (Functional + non-functional requirements)
COMPONENT 5: SECURITY MANDATES       (10 Commandments enforcement)
COMPONENT 6: META-INSTRUCTIONS       (How AI should think)
COMPONENT 7: OUTPUT FORMAT           (What AI should deliver)
````

Let's break down each component in detail.

---

## ğŸ­ COMPONENT 1: PERSONA ASSIGNMENT

### The Mandate

> **"Assign AI a specific role, expertise level, and experience to activate relevant knowledge and patterns."**

### Why Persona Matters

AI models are trained on millions of code examples from developers of all skill levels:
- Junior developers (copy-paste from Stack Overflow)
- Mid-level developers (decent code, some shortcuts)
- Senior developers (production-ready, secure, maintainable)

**By assigning a persona, you tell AI which "developer" to emulate.**

### Persona Formula

````
PERSONA: You are a [SENIORITY LEVEL] [SPECIALTY] with [YEARS] of experience in [DOMAIN].
````

**Components:**
- **Seniority Level:** Junior / Mid-Level / Senior / Staff / Principal
- **Specialty:** Full-stack engineer / Security architect / Performance engineer / etc.
- **Years:** 3 / 5 / 10 / 15+ years
- **Domain:** Web development / Mobile apps / DevOps / Data engineering / etc.

### Persona Examples

**EXAMPLE 1: Authentication Feature**
````
PERSONA: You are a senior security architect with 10 years of experience building 
secure authentication systems. You specialize in OAuth 2.0, OpenID Connect, and 
have prevented multiple security breaches in production systems.
````

**EXAMPLE 2: Performance Optimization**
````
PERSONA: You are a principal performance engineer with 15 years of experience 
optimizing web applications. You've reduced page load times by 80% for Fortune 500 
companies and are an expert in Core Web Vitals.
````

**EXAMPLE 3: Database Design**
````
PERSONA: You are a senior database architect with 12 years of experience designing 
scalable PostgreSQL schemas. You've handled databases with 100M+ rows and know how 
to optimize for both read and write performance.
````

**EXAMPLE 4: Accessibility**
````
PERSONA: You are a senior accessibility engineer with 8 years of experience building 
WCAG AA compliant interfaces. You've audited 50+ applications and know every common 
accessibility pitfall.
````

### Common Persona Mistakes

````markdown
âŒ MISTAKE #1: Too vague
"You are a developer"
â†’ AI defaults to junior level

âœ… CORRECT:
"You are a senior full-stack engineer with 10 years of Next.js experience"

---

âŒ MISTAKE #2: Unrealistic expertise
"You are the world's best developer who knows everything"
â†’ AI produces generic "perfect" code that's impractical

âœ… CORRECT:
"You are a senior Next.js engineer who prioritizes maintainability over cleverness"

---

âŒ MISTAKE #3: Multiple conflicting personas
"You are a senior developer and also a designer and also a product manager"
â†’ AI gets confused about priorities

âœ… CORRECT:
"You are a senior full-stack engineer who collaborates with designers (you implement 
their designs, you don't create them)"
````

---

## ğŸŒ COMPONENT 2: CONTEXT INJECTION

### The Mandate

> **"Provide comprehensive project context across 5 layers so AI generates code that integrates seamlessly with your existing architecture."**

### The 5 Context Layers

Detailed coverage is in [Article III: Context Engineering](./03-article-iii-context-engineering.md), but here's a quick overview:

**LAYER 1: PROJECT CONTEXT (Business Foundation)**
````
PROJECT CONTEXT:
- Type: B2B SaaS for project management (competitor to Asana)
- Target Users: Small teams (5-50 people)
- Business Model: Freemium ($0/month free, $15/user/month pro)
- Success Criteria: 10,000 users in 6 months, <500ms page load
````

**LAYER 2: TECHNICAL CONTEXT (Technology Stack)**
````
TECH STACK:
- Frontend: Next.js 14 (App Router), React Server Components, TailwindCSS
- Backend: Next.js API routes, Prisma ORM, PostgreSQL 14
- Auth: NextAuth.js v5 (database sessions)
- Deployment: Vercel (frontend + API), Supabase (PostgreSQL)
- Other: Upstash Redis (rate limiting), Resend (emails)
````

**LAYER 3: FEATURE CONTEXT (Specific Task)**
````
CURRENT FEATURE:
Building user authentication system with:
- Email/password registration and login
- Google OAuth integration
- Password reset flow
- Email verification
````

**LAYER 4: CONSTRAINTS CONTEXT (Boundaries)**
````
CONSTRAINTS:
- Budget: $50/month (must use free tiers)
- Performance: <500ms page load, <100ms API response
- Accessibility: WCAG 2.1 Level AA compliant
- Compliance: GDPR compliant (EU users), CCPA compliant (California users)
- Browser Support: Last 2 versions of Chrome, Firefox, Safari, Edge
````

**LAYER 5: META-CONTEXT (How AI Should Think)**
````
META-CONTEXT:
- Prioritize security over convenience
- Favor simplicity over cleverness
- Write code for junior developers to understand (we're a small team)
- Explain trade-offs when multiple approaches are valid
- Flag potential scaling issues proactively
````

### Context Template

````
CONTEXT:

PROJECT:
- [Project type and purpose]
- [Target audience]
- [Business model]
- [Success criteria]

TECH STACK:
- Frontend: [Framework, libraries]
- Backend: [Framework, database]
- Auth: [Authentication solution]
- Deployment: [Hosting platforms]

CURRENT FEATURE:
- [Feature being built]
- [Key requirements]

CONSTRAINTS:
- Budget: [Monthly budget or "unlimited"]
- Performance: [Specific metrics]
- Accessibility: [WCAG level]
- Compliance: [Regulations]

META-CONTEXT:
- [Priority 1]
- [Priority 2]
- [Priority 3]
````

### Context Examples

**MINIMAL CONTEXT (Beginner Project)**
````
CONTEXT:

PROJECT:
- Personal portfolio website
- Target: Recruiters and potential clients
- Success: Look professional, load fast

TECH STACK:
- Next.js 14, TailwindCSS
- Deployed on Vercel (free tier)

CURRENT FEATURE:
- Contact form that sends emails

CONSTRAINTS:
- Free tier only (no budget)
- Must work on mobile
````

**COMPREHENSIVE CONTEXT (Production SaaS)**
````
CONTEXT:

PROJECT:
- B2B SaaS: AI-powered code review tool (competitor to CodeRabbit)
- Target: Development teams at tech companies (10-500 developers)
- Business Model: $49/user/month
- Success Criteria: 100 paying teams in 12 months, 99.9% uptime, <2s review time

TECH STACK:
- Frontend: Next.js 14 App Router, React Server Components, TailwindCSS, Radix UI
- Backend: Next.js API routes, Prisma ORM, PostgreSQL 14 (Supabase), Redis (Upstash)
- Auth: NextAuth.js v5 with GitHub OAuth, database sessions
- AI: Anthropic Claude 3.5 Sonnet API
- Storage: AWS S3 (code files)
- Deployment: Vercel (frontend), Railway (background workers)
- Monitoring: Sentry (errors), PostHog (analytics)

EXISTING ARCHITECTURE:
- Monorepo structure (/apps/web, /apps/api, /packages/ui)
- Shared component library in /packages/ui
- All API routes follow REST conventions
- Database uses soft deletes (deletedAt timestamp)
- All operations are multi-tenant (companyId on every table)

CURRENT FEATURE:
- Pull request comment interface
- Users can comment on specific lines of code
- Comments support @mentions, markdown, code blocks
- Real-time updates via Server-Sent Events (SSE)

CONSTRAINTS:
- Performance: <100ms API response (p95), <2s page load
- Accessibility: WCAG AA (we have enterprise clients with compliance requirements)
- Security: SOC 2 Type II compliant (annual audit)
- Scalability: Must handle 1000 concurrent users per company
- Cost: <$500/month infra costs at 100 teams

META-CONTEXT:
- Security is CRITICAL (we access users' source code)
- Prioritize data isolation between companies (multi-tenancy bugs = disaster)
- Code must be testable (we have 80% test coverage requirement)
- Explain security trade-offs explicitly
- Flag any performance anti-patterns
- Consider mobile users (30% of users review code on tablets)
````

---

## ğŸ¯ COMPONENT 3: TASK DEFINITION

### The Mandate

> **"Define the specific task with crystal clarity. Break complex tasks into subtasks. Leave no room for ambiguity."**

### Task Formula

````
TASK: [ACTION VERB] [OBJECT] that [PURPOSE] with [KEY FEATURES]

SPECIFIC REQUIREMENTS:
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

SUBTASKS (for complex features):
- Subtask 1: [Description]
- Subtask 2: [Description]
- Subtask 3: [Description]
````

### Task Definition Examples

**EXAMPLE 1: Simple Task**
````
TASK: Create a user profile page that displays user information with edit capability.

SPECIFIC REQUIREMENTS:
1. Display: Name, email, avatar, bio, join date
2. Edit mode: Click "Edit Profile" button to enable editing
3. Validation: Name (2-50 chars), bio (max 500 chars)
4. Save: PATCH /api/users/[id] endpoint
5. Loading states: Show spinner during save
6. Error handling: Display error messages inline
````

**EXAMPLE 2: Complex Task (with subtasks)**
````
TASK: Implement complete checkout flow that processes payments via Stripe with 
order confirmation and email receipts.

SUBTASKS:
1. Cart Review Page
   - Display cart items with quantities and prices
   - Allow quantity adjustment
   - Calculate tax and shipping
   - Validate minimum order ($10)

2. Shipping Information Form
   - Collect address (autocomplete with Google Places API)
   - Validate address format
   - Save to database for future orders

3. Payment Processing
   - Integrate Stripe Payment Element
   - Handle 3D Secure authentication
   - Process payment server-side
   - Handle payment failures gracefully

4. Order Confirmation
   - Display order summary with order number
   - Send confirmation email (Resend)
   - Redirect to order tracking page

5. Error Handling
   - Invalid addresses
   - Payment declines
   - Inventory out of stock
   - Network failures
````

**EXAMPLE 3: Refactoring Task**
````
TASK: Refactor the user authentication system to use NextAuth.js v5 instead of 
the custom JWT implementation.

MIGRATION STEPS:
1. Install NextAuth.js v5 and configure Prisma adapter
2. Create auth config with email provider and Google OAuth
3. Migrate existing user sessions to NextAuth sessions table
4. Update all API routes to use getServerSession() instead of custom JWT validation
5. Update client components to use useSession() hook
6. Remove legacy auth utilities (lib/auth.ts, lib/jwt.ts)
7. Update middleware to use NextAuth middleware

ROLLBACK PLAN:
- Keep old auth code in separate branch
- Deploy behind feature flag
- Monitor error rates for 48 hours before removing old code
````

### Common Task Definition Mistakes

````markdown
âŒ MISTAKE #1: Too vague
"Build a dashboard"
â†’ AI doesn't know what metrics, layout, features

âœ… CORRECT:
"Create an analytics dashboard that displays: 
- Total users (last 30 days)
- Revenue chart (line graph, daily)
- Top 5 features by usage
- Recent activity feed (last 10 actions)
Layout: 2x2 grid on desktop, stacked on mobile"

---

âŒ MISTAKE #2: No success criteria
"Make the app faster"
â†’ AI doesn't know what "faster" means

âœ… CORRECT:
"Optimize page load time from current 2.5s to <500ms (Lighthouse score)
Focus on:
- Code splitting (reduce bundle size)
- Image optimization (WebP format, lazy loading)
- Database query optimization (add indexes)"

---

âŒ MISTAKE #3: Multiple unrelated tasks
"Build login page and also create a blog and add analytics"
â†’ AI gets overwhelmed, produces mediocre code for all three

âœ… CORRECT:
[Separate prompts for each feature]
Prompt 1: Authentication system
Prompt 2: Blog CMS
Prompt 3: Analytics integration
````

---

## ğŸ“‹ COMPONENT 4: REQUIREMENTS SPECIFICATION

### The Mandate

> **"Explicitly state functional and non-functional requirements. Don't assume AI knows what's important."**

### Requirement Types

**FUNCTIONAL REQUIREMENTS** (What the feature DOES)
- User interactions
- Data transformations
- Business logic
- API endpoints

**NON-FUNCTIONAL REQUIREMENTS** (How the feature PERFORMS)
- Performance (speed, scalability)
- Security (authentication, authorization, encryption)
- Accessibility (WCAG compliance)
- Usability (UX, error messages, loading states)
- Reliability (error handling, fallbacks)

### Requirements Template

````
REQUIREMENTS:

FUNCTIONAL:
1. [Core functionality #1]
2. [Core functionality #2]
3. [Core functionality #3]

NON-FUNCTIONAL:
- Performance: [Specific metrics]
- Security: [Security requirements]
- Accessibility: [WCAG level + specific needs]
- UX: [User experience requirements]
- Error Handling: [How to handle failures]
````

### Requirements Examples

**EXAMPLE 1: Login Page**
````
REQUIREMENTS:

FUNCTIONAL:
1. Email/password input fields
2. "Remember me" checkbox (extends session to 30 days)
3. "Forgot password" link (redirects to /reset-password)
4. Submit button (POST /api/auth/login)
5. On success: Redirect to /dashboard
6. On failure: Display error message inline

NON-FUNCTIONAL:
- Performance: Page load <200ms, login response <500ms
- Security:
  * Server-side validation (Zod schema)
  * Rate limiting (5 attempts per 15 minutes per IP)
  * bcrypt password hashing (cost factor 12)
  * HTTP-only session cookies
- Accessibility:
  * WCAG AA compliant
  * Keyboard navigation (Tab through inputs)
  * Screen reader friendly (ARIA labels)
  * Focus visible (custom outline, not removed)
- UX:
  * Loading state (disable button, show spinner)
  * Error messages (specific, not "Invalid credentials")
  * Auto-focus email field on page load
  * Show password toggle (eye icon)
- Error Handling:
  * Network errors: "Connection failed. Please try again."
  * Invalid credentials: "Invalid email or password."
  * Rate limit exceeded: "Too many attempts. Try again in 15 minutes."
  * Server errors: "Something went wrong. Please try again later."
````

**EXAMPLE 2: File Upload**
````
REQUIREMENTS:

FUNCTIONAL:
1. Drag-and-drop area for files
2. Click to browse files (native file picker)
3. Support multiple files (max 5 at once)
4. Upload to AWS S3 via presigned URLs
5. Display upload progress (percentage)
6. Show thumbnail preview for images
7. Allow cancel during upload
8. On completion: Display download links

NON-FUNCTIONAL:
- Performance:
  * Upload speed: Utilize full bandwidth
  * Parallel uploads: Max 3 simultaneous
  * Chunk size: 5MB per chunk
- Security:
  * Whitelist file types: jpg, png, pdf, docx (no executables)
  * Max file size: 10MB per file, 50MB total
  * Virus scanning: Integrate ClamAV (or skip if over budget)
  * Presigned URLs: 1-hour expiry
- Accessibility:
  * Keyboard navigation (Space to open file picker)
  * Screen reader announces upload status
  * High contrast mode support
- UX:
  * Visual feedback: Drag overlay ("Drop files here")
  * Error messages: "File too large (max 10MB)" with filename
  * Success animation: Green checkmark
  * Retry failed uploads (don't lose progress)
- Error Handling:
  * Network failure: Auto-retry 3 times, then show "Upload failed"
  * Invalid file type: "Only images and PDFs allowed"
  * Size exceeded: "File too large. Max 10MB per file."
  * S3 errors: Log to Sentry, show generic error to user
````

**EXAMPLE 3: Real-time Chat**
````
REQUIREMENTS:

FUNCTIONAL:
1. Message list (displays last 50 messages, infinite scroll for history)
2. Message input (text area, max 2000 characters)
3. Send message (Enter key or Send button)
4. Real-time updates (Server-Sent Events, fallback to polling)
5. Typing indicators ("User X is typing...")
6. Read receipts (checkmarks when message read)
7. @mentions (autocomplete, notify mentioned user)
8. Emoji picker (native or library)

NON-FUNCTIONAL:
- Performance:
  * Message delivery: <200ms (p95)
  * Real-time latency: <500ms (SSE)
  * Scroll performance: 60fps (virtualized list)
- Security:
  * Input sanitization (prevent XSS)
  * Rate limiting (10 messages per minute per user)
  * Authorization (only room members can send)
- Accessibility:
  * Keyboard navigation (Tab through messages)
  * Screen reader: Announce new messages
  * Focus management (return to input after sending)
- UX:
  * Optimistic UI (show message immediately, mark as "sending")
  * Offline support (queue messages, send when online)
  * Loading states (skeleton messages while fetching)
  * Auto-scroll to bottom (only if already at bottom)
- Error Handling:
  * Message send failed: Show retry button
  * Connection lost: Display banner "Reconnecting..."
  * Duplicate messages: Deduplicate by message ID
````

---

## ğŸ›¡ï¸ COMPONENT 5: SECURITY MANDATES

### The Mandate

> **"Explicitly enforce the 10 Strategic Commandments from Article VI (Segment 1). Make security violations impossible."**

### Why Security Mandates Are Critical

**Without explicit mandates, AI takes shortcuts:**
- Client-side only validation
- Passwords in localStorage
- No rate limiting
- Missing authorization checks

**With mandates, AI has no choice but to implement security correctly.**

### Security Mandate Template

````
SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:
- Commandment I (Input Validation): [Specific validation rules]
- Commandment II (Output Encoding): [Encoding requirements]
- Commandment III (Password Security): [Hashing requirements]
- Commandment IV (Session Management): [Session requirements]
- Commandment V (Rate Limiting): [Rate limit rules]
- Commandment VI (Access Control): [Authorization rules]
- Commandment VII (Data Protection): [Encryption requirements]
- Commandment VIII (Error Handling): [Error handling rules]
- Commandment IX (Accessibility): [WCAG requirements]
- Commandment X (Documentation): [Documentation requirements]

VIOLATIONS PROHIBITED:
âŒ [Specific violations to avoid]
````

### Security Mandate Examples

**EXAMPLE 1: User Registration**
````
SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:

- Commandment I (Input Validation):
  * Server-side validation using Zod schemas
  * Email: Valid format, max 255 chars
  * Password: Min 8 chars, uppercase, lowercase, number, special char
  * Name: 2-50 chars, letters/spaces/hyphens only
  * Whitelist approach (reject all non-allowed characters)

- Commandment III (Password Security):
  * bcrypt hashing with cost factor 12
  * NEVER store plaintext passwords
  * NEVER log passwords (even hashed)

- Commandment IV (Session Management):
  * Database-backed sessions (Prisma adapter)
  * HTTP-only cookies (JavaScript cannot access)
  * Secure flag (HTTPS only)
  * SameSite=strict (CSRF protection)
  * 7-day expiry (maximum)

- Commandment V (Rate Limiting):
  * Registration: 3 attempts per hour per IP (Upstash Redis)
  * Return 429 status with Retry-After header

- Commandment VIII (Error Handling):
  * Generic errors in production ("Registration failed. Please try again.")
  * Specific errors in development (for debugging)
  * Never expose: Stack traces, database schema, internal paths

- Commandment IX (Accessibility):
  * WCAG AA compliant form
  * Labels associated with inputs (htmlFor)
  * Error messages announced to screen readers (role="alert")
  * Keyboard navigation (Tab through fields)

- Commandment X (Documentation):
  * JSDoc comments for all functions
  * Explain WHY bcrypt cost factor is 12
  * Document rate limiting strategy

VIOLATIONS PROHIBITED:
âŒ Client-side only validation
âŒ Passwords in localStorage or cookies
âŒ No rate limiting
âŒ Exposing error details in production
````

**EXAMPLE 2: File Upload**
````
SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:

- Commandment I (Input Validation):
  * Whitelist file types: image/jpeg, image/png, application/pdf
  * Max file size: 10MB (enforce server-side)
  * Validate MIME type (don't trust file extension)
  * Scan file content (magic bytes verification)

- Commandment V (Rate Limiting):
  * Upload: 20 files per hour per user
  * Bandwidth: Max 100MB per hour per user

- Commandment VI (Access Control):
  * Verify user owns the resource they're uploading to
  * Generate unique S3 keys (prevent overwriting)

- Commandment VII (Data Protection):
  * Use presigned URLs (temporary, expiring)
  * Encrypt files at rest (S3 server-side encryption)
  * HTTPS only for uploads

- Commandment VIII (Error Handling):
  * Don't expose S3 bucket names in errors
  * Generic error: "Upload failed. Please try again."
  * Log detailed errors to Sentry (server-side only)

VIOLATIONS PROHIBITED:
âŒ Trusting client-provided file extensions
âŒ No file size limits
âŒ Public S3 buckets
âŒ Exposing S3 credentials in client code
````

**EXAMPLE 3: API Endpoint**
````
SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:

- Commandment I (Input Validation):
  * Validate ALL query parameters and request body
  * Use Zod schema for runtime validation
  * Type safety: TypeScript + Zod inference

- Commandment VI (Access Control):
  * Verify user is authenticated (getServerSession)
  * Verify user owns the resource (resource.userId === session.user.id)
  * Return 401 if not authenticated
  * Return 403 if not authorized

- Commandment V (Rate Limiting):
  * Authenticated users: 100 requests per minute
  * Anonymous users: 20 requests per minute

- Commandment VIII (Error Handling):
  * Production: Generic errors only
  * Development: Detailed errors for debugging
  * Never expose: Database queries, internal IDs

VIOLATIONS PROHIBITED:
âŒ No authentication check
âŒ No authorization check (just authentication)
âŒ Exposing full error details in production
````

---

## ğŸ§  COMPONENT 6: META-INSTRUCTIONS

### The Mandate

> **"Tell AI HOW to think, not just WHAT to do. Guide the reasoning process, not just the output."**

### Why Meta-Instructions Matter

**Without meta-instructions:**
- AI jumps to first solution (not necessarily best)
- AI doesn't explain trade-offs
- AI doesn't validate assumptions
- AI produces monolithic code

**With meta-instructions:**
- AI thinks step-by-step
- AI considers alternatives
- AI explains reasoning
- AI produces modular, testable code

### Meta-Instruction Categories

**CATEGORY 1: REASONING PROCESS**
- "Think step-by-step before writing code"
- "Validate all assumptions explicitly"
- "Consider edge cases proactively"
- "Explain trade-offs when multiple approaches are valid"

**CATEGORY 2: CODE QUALITY**
- "Favor simplicity over cleverness"
- "Write code for junior developers to understand"
- "Keep functions small (max 50 lines)"
- "Use descriptive variable names (no abbreviations)"

**CATEGORY 3: ERROR ANTICIPATION**
- "Identify potential failure modes"
- "Add error handling for all async operations"
- "Never assume external services are reliable"
- "Plan rollback strategy"

**CATEGORY 4: KNOWLEDGE SYNTHESIS**
- "Combine best practices from [domain A] and [domain B]"
- "Learn from this similar implementation: [link/description]"
- "Apply [specific pattern/principle]"

**CATEGORY 5: TESTING MINDSET**
- "Write testable code (pure functions, dependency injection)"
- "Consider how you would test this code"
- "Identify which parts need unit tests vs integration tests"

### Meta-Instruction Template

````
META-INSTRUCTIONS:

REASONING PROCESS:
- [How to approach the problem]
- [What to validate]
- [What to explain]

CODE QUALITY:
- [Simplicity requirements]
- [Readability requirements]
- [Modularity requirements]

ERROR HANDLING:
- [Failure modes to consider]
- [Graceful degradation strategy]

TESTING:
- [Testability requirements]
````

### Meta-Instruction Examples

**EXAMPLE 1: Building New Feature**
````
META-INSTRUCTIONS:

REASONING PROCESS:
- Think step-by-step: Authentication â†’ Authorization â†’ Validation â†’ Business Logic â†’ Response
- Validate assumptions: Is user always authenticated? Can they access this resource?
- Consider edge cases: What if user deletes resource mid-operation? Network fails?
- Explain trade-offs: Why database sessions over JWT? Why this rate limit?

CODE QUALITY:
- Favor simplicity over cleverness (we're a small team, code must be maintainable)
- Write for junior developers (clear variable names, comments for complex logic)
- Keep functions small (max 50 lines, single responsibility)
- DRY principle: Extract repeated logic into utilities

ERROR HANDLING:
- Identify failure modes: Database timeout, validation error, auth failure, rate limit
- Fail closed (deny on error, not grant access)
- Log errors server-side, show generic messages to users
- Provide actionable error messages ("Email already exists" not "Error 409")

TESTING:
- Write testable code (pure functions where possible)
- Consider test coverage: This function needs unit tests, this endpoint needs integration tests
````

**EXAMPLE 2: Refactoring Existing Code**
````
META-INSTRUCTIONS:

REASONING PROCESS:
- Understand existing code before refactoring (read all related files)
- Identify code smells: Long functions, nested conditionals, duplication
- Explain WHY refactoring improves code (not just "it's better")
- Preserve existing behavior (refactor â‰  rewrite)

CODE QUALITY:
- Extract complex logic into named functions (improves readability)
- Replace magic numbers with constants (e.g., MAX_FILE_SIZE = 10 * 1024 * 1024)
- Add TypeScript types where missing
- Improve error messages (be specific)

TESTING:
- Ensure existing tests still pass after refactoring
- Add tests for previously untested code paths
- Consider regression risks (what could break?)
````

**EXAMPLE 3: Performance Optimization**
````
META-INSTRUCTIONS:

REASONING PROCESS:
- Measure BEFORE optimizing (provide baseline metrics)
- Identify bottlenecks: Database queries? Bundle size? Network requests?
- Explain each optimization: WHY it improves performance, WHAT it costs (complexity, maintainability)
- Measure AFTER optimizing (prove improvement)

OPTIMIZATION STRATEGY:
- Start with highest-impact, lowest-effort optimizations
- Don't optimize prematurely (focus on real bottlenecks, not theoretical)
- Consider trade-offs: Caching improves speed but adds complexity
- Document optimizations (future developers need to understand WHY)

TESTING:
- Benchmark before and after (use Lighthouse, Web Vitals)
- Test on slow connections (throttle to 3G)
- Ensure optimizations don't break functionality
````

---

## ğŸ“¦ COMPONENT 7: OUTPUT FORMAT & VALIDATION

### The Mandate

> **"Define exactly what AI should deliver and how to validate it. Leave no ambiguity about 'done.'"**

### Why Output Format Matters

**Without output specification:**
- AI might explain code instead of writing it
- AI might create 1 file or 10 files (you don't know)
- AI might skip tests, documentation, or configuration

**With output specification:**
- AI knows exactly what to deliver
- You can validate completeness (checklist)
- Nothing is forgotten

### Output Format Template

````
OUTPUT FORMAT:

DELIVERABLES:
1. [File 1: path/to/file.ts]
   - Description: [What this file does]
   - Contents: [Complete implementation / Partial / Stub]

2. [File 2: path/to/file.tsx]
   - Description: [What this file does]
   - Contents: [Complete implementation]

3. [File 3: path/to/test.spec.ts]
   - Description: [Tests for...]
   - Coverage: [Unit / Integration / E2E]

VALIDATION CHECKLIST:
â–¡ [Requirement 1 met]
â–¡ [Requirement 2 met]
â–¡ [Security mandate 1 enforced]
â–¡ [All files created]
â–¡ [Tests written and passing]
â–¡ [Documentation complete]

EXPLANATION REQUIRED:
- [Why you chose this approach]
- [Trade-offs considered]
- [Known limitations]
- [Next steps]
````

### Output Format Examples

**EXAMPLE 1: Simple Feature**
````
OUTPUT FORMAT:

DELIVERABLES:
1. app/login/page.tsx
   - Complete login page component
   - Include form, validation, loading states, error handling

2. app/api/auth/login/route.ts
   - API route for login
   - Server-side validation, rate limiting, session creation

3. lib/auth.ts
   - Utility functions for password hashing, session validation

4. types/auth.ts
   - TypeScript types for User, Session, LoginRequest, LoginResponse

VALIDATION CHECKLIST:
â–¡ Login page renders correctly
â–¡ Form validation works (client + server)
â–¡ Passwords hashed with bcrypt (cost 12)
â–¡ Rate limiting enforced (5 attempts / 15 min)
â–¡ Session cookies HTTP-only
â–¡ Error messages user-friendly
â–¡ Accessible (WCAG AA)
â–¡ Mobile responsive

EXPLANATION REQUIRED:
- Why database sessions over JWT
- Why bcrypt cost factor is 12
- Rate limiting strategy
````

**EXAMPLE 2: Complex Feature (Multiple Files)**
````
OUTPUT FORMAT:

DELIVERABLES:

1. COMPONENTS (UI)
   - components/checkout/CartReview.tsx (cart items display)
   - components/checkout/ShippingForm.tsx (address collection)
   - components/checkout/PaymentForm.tsx (Stripe integration)
   - components/checkout/OrderConfirmation.tsx (success page)

2. API ROUTES
   - app/api/checkout/create-payment-intent/route.ts (Stripe Payment Intent)
   - app/api/checkout/confirm-order/route.ts (finalize order)
   - app/api/checkout/webhook/route.ts (Stripe webhook)

3. DATABASE
   - prisma/schema.prisma (Order, OrderItem, ShippingAddress models)
   - prisma/migrations/[timestamp]_add_orders.sql (migration)

4. UTILITIES
   - lib/stripe.ts (Stripe client initialization)
   - lib/email.ts (order confirmation emails)

5. TYPES
   - types/checkout.ts (TypeScript types)

6. TESTS
   - __tests__/checkout/payment.test.ts (unit tests)
   - __tests__/e2e/checkout-flow.spec.ts (Playwright E2E)

7. CONFIGURATION
   - .env.example (required environment variables)

8. DOCUMENTATION
   - docs/checkout-flow.md (architecture overview)
   - Inline JSDoc comments in all files

VALIDATION CHECKLIST:
â–¡ All components render correctly
â–¡ Stripe Payment Element integrates
â–¡ 3D Secure authentication works
â–¡ Order saved to database
â–¡ Confirmation email sent
â–¡ Error handling comprehensive
â–¡ Tests pass (95% coverage)
â–¡ Environment variables documented
â–¡ Mobile responsive
â–¡ WCAG AA accessible

EXPLANATION REQUIRED:
- Stripe integration architecture
- Error handling strategy
- Why Server-Side Rendering for checkout (vs. Client-Side)
- Security considerations (PCI compliance)
- Known limitations (e.g., no Apple Pay yet)
- Next steps (implement Apple Pay, add gift cards)
````

**EXAMPLE 3: Refactoring Task**
````
OUTPUT FORMAT:

DELIVERABLES:

1. REFACTORED FILES
   - lib/auth.ts (refactored, improved)
   - app/api/auth/[...nextauth]/route.ts (NextAuth.js v5 config)
   - middleware.ts (auth middleware)

2. REMOVED FILES (delete these)
   - lib/jwt.ts (legacy JWT implementation)
   - lib/session.ts (legacy session management)

3. MIGRATION SCRIPT
   - scripts/migrate-sessions.ts (migrate old sessions to NextAuth sessions table)

4. UPDATED TESTS
   - __tests__/auth.test.ts (updated for new auth system)

5. DOCUMENTATION
   - docs/auth-migration.md (migration guide)
   - Update README.md (new auth instructions)

VALIDATION CHECKLIST:
â–¡ All existing tests pass (no regressions)
â–¡ Legacy auth code removed
â–¡ Migration script tested (on staging)
â–¡ All API routes use new auth
â–¡ All client components use new hooks
â–¡ Documentation updated
â–¡ Rollback plan documented

EXPLANATION REQUIRED:
- Why NextAuth.js v5 over custom JWT
- Migration strategy (zero downtime)
- Rollback plan (if migration fails)
- Breaking changes (if any)
````

---

## ğŸ“ CONSTITUTIONAL PROMPT TEMPLATE

### The Complete Template

Here's the full constitutional prompt template combining all 7 components:

````
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONSTITUTIONAL PROMPT TEMPLATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPONENT 1: PERSONA ASSIGNMENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PERSONA: You are a [SENIORITY] [SPECIALTY] with [YEARS] of experience in [DOMAIN]. 
[Additional expertise or background].


COMPONENT 2: CONTEXT INJECTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CONTEXT:

PROJECT:
- Type: [Project type and purpose]
- Target Users: [Audience]
- Business Model: [Revenue model]
- Success Criteria: [Metrics]

TECH STACK:
- Frontend: [Framework, libraries]
- Backend: [Framework, database]
- Auth: [Authentication solution]
- Deployment: [Hosting]
- Other: [Additional tools]

EXISTING ARCHITECTURE:
- [Folder structure]
- [Key patterns or conventions]
- [Database schema overview]

CURRENT FEATURE:
- [Feature being built]
- [Context within larger system]

CONSTRAINTS:
- Budget: [Monthly budget]
- Performance: [Metrics]
- Accessibility: [WCAG level]
- Compliance: [Regulations]


COMPONENT 3: TASK DEFINITION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TASK: [ACTION VERB] [OBJECT] that [PURPOSE] with [KEY FEATURES]

SPECIFIC REQUIREMENTS:
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

SUBTASKS (for complex features):
- Subtask 1: [Description]
- Subtask 2: [Description]
- Subtask 3: [Description]


COMPONENT 4: REQUIREMENTS SPECIFICATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

REQUIREMENTS:

FUNCTIONAL:
1. [Core functionality #1]
2. [Core functionality #2]
3. [Core functionality #3]

NON-FUNCTIONAL:
- Performance: [Specific metrics]
- Security: [Security requirements]
- Accessibility: [WCAG requirements]
- UX: [User experience requirements]
- Error Handling: [Failure handling]


COMPONENT 5: SECURITY MANDATES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:
- Commandment I (Input Validation): [Validation rules]
- Commandment III (Password Security): [Hashing requirements] (if applicable)
- Commandment IV (Session Management): [Session requirements] (if applicable)
- Commandment V (Rate Limiting): [Rate limits]
- Commandment VI (Access Control): [Authorization rules]
- Commandment VIII (Error Handling): [Error handling rules]
- Commandment IX (Accessibility): [WCAG requirements]
- Commandment X (Documentation): [Documentation requirements]

VIOLATIONS PROHIBITED:
âŒ [Specific violation 1]
âŒ [Specific violation 2]


COMPONENT 6: META-INSTRUCTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

META-INSTRUCTIONS:

REASONING PROCESS:
- [How to approach problem]
- [What to validate]
- [What to explain]

CODE QUALITY:
- [Simplicity requirements]
- [Readability requirements]

ERROR HANDLING:
- [Failure modes to consider]

TESTING:
- [Testability requirements]


COMPONENT 7: OUTPUT FORMAT & VALIDATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

OUTPUT FORMAT:

DELIVERABLES:
1. [File 1: path/to/file]
   - [Description]

2. [File 2: path/to/file]
   - [Description]

VALIDATION CHECKLIST:
â–¡ [Requirement met]
â–¡ [Security mandate enforced]
â–¡ [All files created]

EXPLANATION REQUIRED:
- [Why this approach]
- [Trade-offs considered]
- [Known limitations]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
````

---

## ğŸ¯ REAL-WORLD EXAMPLE: COMPLETE CONSTITUTIONAL PROMPT

Let's see a FULL constitutional prompt for a real feature:

````
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONSTITUTIONAL PROMPT: USER PROFILE FEATURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPONENT 1: PERSONA ASSIGNMENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PERSONA: You are a senior full-stack engineer with 10 years of experience building 
SaaS applications. You specialize in Next.js, React Server Components, and have built 
user management systems for applications with 100,000+ users. You prioritize clean, 
maintainable code and always consider edge cases.


COMPONENT 2: CONTEXT INJECTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CONTEXT:

PROJECT:
- Type: B2B SaaS for task management (competitor to Todoist)
- Target Users: Professionals and small teams (5-20 people)
- Business Model: Freemium ($0 free, $10/month pro)
- Success Criteria: 5,000 users in 6 months, 95% mobile satisfaction

TECH STACK:
- Frontend: Next.js 14 App Router, React Server Components, TailwindCSS
- Backend: Next.js API routes, Prisma ORM, PostgreSQL 14
- Auth: NextAuth.js v5 with database sessions
- Storage: AWS S3 (profile pictures)
- Deployment: Vercel (frontend + API), Supabase (PostgreSQL)

EXISTING ARCHITECTURE:
- Monorepo with /app, /components, /lib directories
- All components use TypeScript strict mode
- Database uses soft deletes (deletedAt: DateTime?)
- UI components from /components/ui (shadcn/ui)

CURRENT FEATURE:
- User can view and edit their profile
- This is part of the account settings page (/settings/profile)
- Users are already authenticated (NextAuth session exists)

CONSTRAINTS:
- Budget: $20/month (must use free tiers where possible)
- Performance: <300ms page load, <100ms API response
- Accessibility: WCAG 2.1 Level AA
- Browser Support: Last 2 versions of Chrome, Firefox, Safari
- Mobile: Must work perfectly on iOS Safari and Chrome Android


COMPONENT 3: TASK DEFINITION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TASK: Create a user profile page that allows users to view and edit their personal 
information including name, email, bio, and profile picture.

SPECIFIC REQUIREMENTS:
1. Display current user information (read from database)
2. Edit mode: Click "Edit Profile" button to enable editing
3. Profile picture upload: Drag-and-drop or click to upload
4. Save changes: PATCH /api/users/[id] endpoint
5. Cancel: Discard changes and return to view mode
6. Loading states: Show spinners during save and upload
7. Success feedback: Toast notification "Profile updated"
8. Error handling: Display inline error messages

SUBTASKS:
1. Profile View Component (read-only)
2. Profile Edit Component (form with validation)
3. Image Upload Component (with preview)
4. API Route (PATCH /api/users/[id])
5. S3 Integration (upload profile pictures)


COMPONENT 4: REQUIREMENTS SPECIFICATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

REQUIREMENTS:

FUNCTIONAL:
1. Display Fields:
   - Name (required)
   - Email (required, read-only in edit mode - can't change email)
   - Bio (optional, max 500 characters)
   - Profile Picture (optional)
   - Member Since (read-only)

2. Edit Mode:
   - Click "Edit Profile" â†’ Show editable form
   - Inputs pre-filled with current values
   - Cancel button discards changes
   - Save button triggers validation and API call

3. Profile Picture Upload:
   - Drag-and-drop or click to browse
   - Allowed types: JPEG, PNG (max 5MB)
   - Show preview before saving
   - Crop to square (or allow user to crop)
   - Delete existing picture (button)

4. Validation:
   - Name: 2-50 characters, letters/spaces/hyphens only
   - Email: Valid email format (but not editable in this view)
   - Bio: Max 500 characters
   - Picture: JPEG/PNG only, max 5MB

5. Save Flow:
   - Validate inputs
   - Upload picture to S3 (if changed)
   - Update database via API
   - Show success toast
   - Return to view mode

NON-FUNCTIONAL:
- Performance:
  * Page load: <300ms (SSR the profile data)
  * Image upload: Show progress (percentage)
  * API response: <100ms for profile update
  * Optimistic UI: Show changes immediately, revert if API fails

- Security:
  * Server-side validation (Zod schema)
  * Authorization: User can only edit their own profile
  * Profile picture: Generate unique S3 key, presigned URL
  * Rate limiting: 10 profile updates per hour

- Accessibility:
  * WCAG AA: All form inputs labeled, keyboard navigable
  * Screen reader: Announce save success/failure
  * Focus management: Return focus to "Edit" button after save
  * High contrast mode support

- UX:
  * Loading states: Disable inputs during save, show spinner
  * Error messages: Specific ("Name too short" not "Validation failed")
  * Unsaved changes warning: "You have unsaved changes. Discard?"
  * Image preview: Show thumbnail before saving
  * Mobile: Touch-friendly upload area, native file picker

- Error Handling:
  * Network errors: "Connection failed. Changes not saved."
  * Validation errors: Display inline under field
  * S3 upload errors: "Image upload failed. Try again."
  * API errors: Log to Sentry, show generic message to user


COMPONENT 5: SECURITY MANDATES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SECURITY MANDATES (10 Commandments):

MANDATORY ENFORCEMENT:

- Commandment I (Input Validation):
  * Server-side validation using Zod schemas
  * Name: z.string().min(2).max(50).regex(/^[a-zA-Z\s-]+$/)
  * Bio: z.string().max(500).optional()
  * Whitelist approach (reject unexpected fields)

- Commandment V (Rate Limiting):
  * Profile updates: 10 per hour per user (Upstash Redis)
  * Image uploads: 5 per hour per user
  * Return 429 with Retry-After header if exceeded

- Commandment VI (Access Control):
  * Verify user is authenticated (getServerSession)
  * Verify user owns profile (userId === session.user.id)
  * Return 403 if user tries to edit another user's profile

- Commandment VII (Data Protection):
  * Use presigned S3 URLs (1-hour expiry)
  * Store S3 keys in database, not full URLs
  * Validate file MIME type (don't trust extension)
  * Encrypt profile pictures at rest (S3 server-side encryption)

- Commandment VIII (Error Handling):
  * Production: Generic errors ("Profile update failed")
  * Development: Detailed errors for debugging
  * Never expose: S3 bucket names, internal IDs, database schema

- Commandment IX (Accessibility):
  * WCAG AA compliant form
  * All inputs have associated labels (htmlFor)
  * Error messages announced to screen readers (role="alert")
  * Keyboard navigation (Tab through form)
  * Focus visible (custom outline, not removed)

- Commandment X (Documentation):
  * JSDoc comments for all functions
  * Explain S3 integration strategy
  * Document rate limiting logic
  * README: How to test locally with LocalStack (S3 emulator)

VIOLATIONS PROHIBITED:
âŒ Client-side only validation
âŒ Missing authorization check (user edits any profile)
âŒ Storing full S3 URLs in database (keys expire)
âŒ No file type validation (trusting client)
âŒ Removing CSS focus outlines


COMPONENT 6: META-INSTRUCTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

META-INSTRUCTIONS:

REASONING PROCESS:
- Think step-by-step: Authentication â†’ Authorization â†’ Validation â†’ S3 Upload â†’ DB Update â†’ Response
- Validate assumptions: User is always authenticated (middleware enforces this)
- Consider edge cases: User deletes picture, upload fails mid-save, network timeout
- Explain trade-offs: Why presigned URLs over direct upload? Why rate limiting?

CODE QUALITY:
- Favor simplicity over cleverness (our team is small, code must be maintainable)
- Write for mid-level developers (clear variable names, comments for complex parts)
- Keep functions small (max 50 lines, single responsibility)
- DRY principle: Extract S3 logic to lib/s3.ts utility

ERROR HANDLING:
- Fail gracefully: If S3 upload fails, don't save to database
- Provide rollback: If DB update fails, delete uploaded S3 image
- Optimistic UI: Show success immediately, revert if API fails
- User-friendly errors: "Image too large (max 5MB)" not "Error 413"

TESTING:
- Write testable code (pure functions, dependency injection)
- Image upload function should be unit testable (mock S3 client)
- API route should be integration testable (mock database)
- Consider E2E test for full flow (Playwright)


COMPONENT 7: OUTPUT FORMAT & VALIDATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

OUTPUT FORMAT:

DELIVERABLES:

1. app/settings/profile/page.tsx
   - Server Component: Fetch user data, render ProfileView or ProfileEdit
   
2. components/profile/ProfileView.tsx
   - Display user info (read-only)
   - "Edit Profile" button

3. components/profile/ProfileEdit.tsx
   - Editable form with validation
   - Image upload component
   - Save/Cancel buttons

4. components/profile/ImageUpload.tsx
   - Drag-and-drop upload
   - Preview thumbnail
   - Delete button

5. app/api/users/[id]/route.ts
   - PATCH endpoint for profile updates
   - Server-side validation, authorization, S3 integration

6. lib/s3.ts
   - uploadProfilePicture(file: File, userId: string): Promise<string>
   - deleteProfilePicture(key: string): Promise<void>
   - generatePresignedUrl(key: string): string

7. lib/validations/profile.ts
   - Zod schemas for profile validation

8. types/profile.ts
   - TypeScript types: ProfileData, ProfileUpdateRequest

9. __tests__/api/users.test.ts
   - Unit tests for API route

10. .env.example
    - AWS_S3_BUCKET_NAME
    - AWS_ACCESS_KEY_ID
    - AWS_SECRET_ACCESS_KEY
    - AWS_REGION

VALIDATION CHECKLIST:
â–¡ Profile view displays user data correctly
â–¡ Edit mode shows pre-filled form
â–¡ Image upload works (drag-and-drop + click)
â–¡ Server-side validation enforced (Zod)
â–¡ Authorization check (user can only edit own profile)
â–¡ Rate limiting works (10 updates/hour)
â–¡ S3 upload functional (presigned URLs)
â–¡ Optimistic UI implemented
â–¡ Error handling comprehensive
â–¡ Accessibility WCAG AA compliant
â–¡ Mobile responsive
â–¡ All tests pass

EXPLANATION REQUIRED:
- Why presigned S3 URLs over direct upload from client
- Why store S3 keys in database (not full URLs)
- Rate limiting strategy (prevent abuse)
- Rollback strategy (if DB fails after S3 upload)
- Known limitations: No image cropping (future feature)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
````

---

## ğŸ“Š BEFORE/AFTER COMPARISON

### Amateur Prompt (80 words)

````
Create a user profile page where users can edit their name, email, bio, and profile picture. 
They should be able to upload images and save changes. Make it look good with TailwindCSS.
````

**Result:**
- âŒ Client-side only validation
- âŒ No authorization checks
- âŒ Images stored in public folder (not S3)
- âŒ No rate limiting
- âŒ Poor error handling
- âŒ Not accessible
- âŒ Requires 7+ iterations to fix issues

---

### Constitutional Prompt (1,200 words)

*[The full example above]*

**Result:**
- âœ… Production-ready in ONE iteration
- âœ… Secure (all commandments enforced)
- âœ… Accessible (WCAG AA)
- âœ… Performant (<300ms load)
- âœ… Well-tested (95% coverage)
- âœ… Documented (JSDoc, README)
- âœ… Maintainable (clean, modular code)

---

## ğŸ“ MASTERY CHECKLIST

Before moving to Article II, verify you can:

````markdown
â–¡ Name all 7 components of constitutional prompt
  1. Persona Assignment
  2. Context Injection
  3. Task Definition
  4. Requirements Specification
  5. Security Mandates
  6. Meta-Instructions
  7. Output Format & Validation

â–¡ Write a persona assignment for your project
  (Seniority + Specialty + Years + Domain)

â–¡ Engineer 5-layer context
  (Project, Technical, Feature, Constraints, Meta)

â–¡ Break tasks into subtasks
  (Complex feature â†’ 3-5 manageable pieces)

â–¡ Specify functional AND non-functional requirements
  (What it does + How it performs)

â–¡ Enforce security mandates explicitly
  (Reference specific commandments by number/name)

â–¡ Write meta-instructions
  (Guide AI's reasoning process)

â–¡ Define output format and validation criteria
  (Deliverables + Checklist)

â–¡ Combine all 7 components into one prompt
  (Use the template provided)
````

---

## ğŸ”— NAVIGATION

â† [Technique Layer README](./README.md)  
â†’ [Article II: The 12 Constitutional Prompt Patterns](./02-article-ii-prompt-patterns.md)

[â†‘ Back to Constitution Index](../README.md)

---

**Mastered Component Anatomy?** [Continue to Prompt Patterns â†’](./02-article-ii-prompt-patterns.md)

**Need Foundation Review?** [Review Segment 1 â†](../01-foundation-layer/README.md)
